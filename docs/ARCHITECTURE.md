# Архитектура «Telegram Bot + Backend API»

## 1. Цели и контекст
- **Разделить ответственность**: Telegram-бот становится тонким клиентом без прямого доступа к БД и RAG.
- **Упростить поддержку**: весь «тяжёлый» функционал (ingestion, RAG, управление пользователями, интеграции) живёт в одном backend-сервисе.
- **Масштабирование**: backend можно запускать отдельно (Gunicorn/Uvicorn, Docker), добавлять кэш, балансировку, фоновые задачи.

## 2. Компоненты
1. **Telegram Frontend**  
   - Получает апдейты, отображает кнопки, форматирует ответы.  
   - Общается только через HTTPS с backend API.  
   - Без доступа к БД/файлам/`rag_system`.

2. **Backend Service (FastAPI)**  
   - **Слои**:  
     - API (`/api/routes/*`) — валидация запросов, авторизация.  
     - Services — бизнес-логика (RAG, ingest, users).  
     - Repositories — работа с БД (SQLAlchemy/async).  
     - Clients — LLM/RAG/внешние интеграции.  
   - **Основные эндпоинты**:  
     - `/auth/telegram`, `/users/*` — управление пользователями.  
     - `/knowledge-bases/*`, `/ingestion/*` — загрузка и управление KB.  
     - `/rag/query`, `/ai/query` — ответы.  
     - `/logs`, `/sources` — метрики и источники.

3. **Общие ресурсы**  
   - База данных (MySQL/SQLite).  
   - Хранилище документов/файлов (локально или S3).  
   - Кэш (Redis) — опционально.  
   - Очередь задач (Celery/RQ) — позже для фоновых ingest задач.

## 3. Поток запросов
1. Пользователь в Telegram выбирает действие.  
2. Бот отправляет запрос на backend (`/rag/query`, `/users/list` и т.д.).  
3. Backend выполняет авторизацию по `telegram_id`, обрабатывает запрос, обращается к БД/RAG.  
4. Ответ возвращается в бот, который форматирует HTML и отправляет пользователю.

## 4. Анализ и лучшие практики
| Точка | Рекомендации | Потенциальные риски |
|-------|--------------|---------------------|
| Аутентификация | Проверять `telegram_id`, опционально подписывать запросы бот-токеном | Подмена запросов без проверки IP/токена |
| API слой | FastAPI + Pydantic схемы, единый error envelope | Непредсказуемые ответы → падение бота |
| Сервисы | Чёткое разделение (users, rag, ingestion) | Утечка логики в API слой |
| БД | Session-per-request, SQLAlchemy ORM или async | Конкурентная запись при ingest без транзакций |
| Логирование | Структурированные логи (JSON) + correlation id (update_id) | Трудно отлаживать без трассировки |
| Очереди | Заложить интерфейсы для фоновых задач | Блокирующие операции (git clone, zip) тормозят API |
| Версионирование API | `/api/v1/...` с контрактами | Ломкие изменения → нужен changelog |
| Безопасность | Rate limiting по `telegram_id`, валидация размеров файлов | DDoS чрезмерными запросами/архивами |
| Конфигурация | .env → backend settings, Secrets в одном месте | Дублирование настроек между ботом и backend |

## 5. Потенциальные проблемы и смягчение
1. **Большие архивы/вики**  
   - Решение: фоновая очередь + прогресс-статус; API сразу возвращает `task_id`.
2. **Смена схемы БД**  
   - Решение: миграции (Alembic) внутри backend; бот unaffected.
3. **Согласованность данных** (бот показывает устаревший статус)  
   - Решение: кэш-инвалидаторы, вебхуки n8n, explicit refresh.
4. **Сложность деплоя**  
   - Решение: docker-compose с двумя сервисами (`bot`, `backend`), общий `.env`.
5. **RAG производительность**  
   - Решение: вынести индексацию в отдельный worker, хранить pre-built индексы, использовать Redis/FAISS server.

## 6. План перехода (фактическое состояние)

**Основные шаги уже выполнены:**

1. Выделен backend‑модуль `backend_service/` с FastAPI‑приложением (`app.py`).  
2. Реализованы и используются из бота API:
   - `/auth/telegram`, `/users/*` — аутентификация и управление пользователями;
   - `/knowledge-bases/*` — создание и список БЗ, очистка/удаление, журнал загрузок;
   - `/ingestion/web`, `/ingestion/wiki-crawl`, `/ingestion/wiki-git`, `/ingestion/wiki-zip` — загрузка веб‑страниц и вики;
   - `/ingestion/document`, `/ingestion/image` — загрузка документов/архивов и изображений;
   - `/rag/query`, `/rag/reload-models` — поиск по БЗ и управление моделями RAG.
3. Telegram‑бот использует **только HTTP‑клиент** `backend_client` для:
   - регистрации/логина пользователей,
   - управления пользователями и базами знаний,
   - всех операций ingestion (веб, wiki, архивы, изображения),
   - RAG‑поиска и перезагрузки моделей.  
4. Прямые вызовы `rag_system` и `KnowledgeImportLog` из кода бота для ingestion и RAG‑поиска удалены и перенесены в backend‑сервисы.  
5. Между ботом и backend настроена простая авторизация по API‑ключу (`X-API-Key`, `BACKEND_API_KEY` в `.env`).  

## 7. Следующие шаги
1. По мере необходимости вынести оставшиеся вспомогательные операции (например, логирование сообщений пользователей) в отдельные backend‑эндпоинты, чтобы бот вообще не создавал `Session`.  
2. Добавить фоновые задачи и очередь (Celery/RQ) для тяжёлых ingest‑операций (git/zip/wiki) и обновить API под async‑модель (`task_id` + polling).  
3. Покрыть ключевые эндпоинты backend юнит‑ и интеграционными тестами (pytest + httpx).  
4. При росте нагрузки — вынести backend в отдельный сервис с балансировкой и кэшем (Redis) и хранением индексов RAG вне процесса.  
5. Документировать внешнее API (OpenAPI + человекочитаемая документация в `docs/`) для потенциального подключения других фронтендов помимо Telegram‑бота.



