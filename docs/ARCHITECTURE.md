# Архитектура «Telegram Bot + Backend API»

## 1. Цели и контекст
- **Разделить ответственность**: Telegram-бот становится тонким клиентом без прямого доступа к БД и RAG.
- **Упростить поддержку**: весь «тяжёлый» функционал (ingestion, RAG, управление пользователями, интеграции) живёт в одном backend-сервисе.
- **Масштабирование**: backend можно запускать отдельно (Gunicorn/Uvicorn, Docker), добавлять кэш, балансировку, фоновые задачи.

## 2. Компоненты
1. **Telegram Frontend**  
   - Получает апдейты, отображает кнопки, форматирует ответы.  
   - Общается только через HTTPS с backend API.  
   - Без доступа к БД/файлам/`rag_system`.

2. **Backend Service (FastAPI)**  
   - **Слои**:  
     - API (`/api/routes/*`) — валидация запросов, авторизация.  
     - Services — бизнес-логика (RAG, ingest, users).  
     - Repositories — работа с БД (SQLAlchemy/async).  
     - Clients — LLM/RAG/внешние интеграции.  
   - **Основные эндпоинты**:  
     - `/auth/telegram`, `/users/*` — управление пользователями.  
     - `/knowledge-bases/*`, `/ingestion/*` — загрузка и управление KB.  
     - `/rag/query`, `/ai/query` — ответы.  
     - `/logs`, `/sources` — метрики и источники.

3. **Общие ресурсы**  
   - База данных (MySQL/SQLite).  
   - Хранилище документов/файлов (локально или S3).  
   - Кэш (Redis) — опционально.  
   - Очередь задач (Celery/RQ) — позже для фоновых ingest задач.

## 3. Поток запросов
1. Пользователь в Telegram выбирает действие.  
2. Бот отправляет запрос на backend (`/rag/query`, `/users/list` и т.д.).  
3. Backend выполняет авторизацию по `telegram_id`, обрабатывает запрос, обращается к БД/RAG.  
4. Ответ возвращается в бот, который форматирует HTML и отправляет пользователю.

## 4. Анализ и лучшие практики
| Точка | Рекомендации | Потенциальные риски |
|-------|--------------|---------------------|
| Аутентификация | Проверять `telegram_id`, опционально подписывать запросы бот-токеном | Подмена запросов без проверки IP/токена |
| API слой | FastAPI + Pydantic схемы, единый error envelope | Непредсказуемые ответы → падение бота |
| Сервисы | Чёткое разделение (users, rag, ingestion) | Утечка логики в API слой |
| БД | Session-per-request, SQLAlchemy ORM или async | Конкурентная запись при ingest без транзакций |
| Логирование | Структурированные логи (JSON) + correlation id (update_id) | Трудно отлаживать без трассировки |
| Очереди | Заложить интерфейсы для фоновых задач | Блокирующие операции (git clone, zip) тормозят API |
| Версионирование API | `/api/v1/...` с контрактами | Ломкие изменения → нужен changelog |
| Безопасность | Rate limiting по `telegram_id`, валидация размеров файлов | DDoS чрезмерными запросами/архивами |
| Конфигурация | .env → backend settings, Secrets в одном месте | Дублирование настроек между ботом и backend |

## 5. Потенциальные проблемы и смягчение
1. **Большие архивы/вики**  
   - Решение: фоновая очередь + прогресс-статус; API сразу возвращает `task_id`.
2. **Смена схемы БД**  
   - Решение: миграции (Alembic) внутри backend; бот unaffected.
3. **Согласованность данных** (бот показывает устаревший статус)  
   - Решение: кэш-инвалидаторы, вебхуки n8n, explicit refresh.
4. **Сложность деплоя**  
   - Решение: docker-compose с двумя сервисами (`bot`, `backend`), общий `.env`.
5. **RAG производительность**  
   - Решение: вынести индексацию в отдельный worker, хранить pre-built индексы, использовать Redis/FAISS server.

## 6. План перехода
1. Выделить backend модуль внутри текущего репо (создан скелет в `backend_service/`).  
2. Реализовать базовые API (`/health`, `/rag/query`, `/users`).  
3. Перевести Telegram-бот на HTTP-клиент к этим эндпоинтам.  
4. Постепенно переносить ingestion, wiki, n8n в backend.  
5. После полного переноса — удалить прямые вызовы `Session`, `rag_system` из бота.

## 7. Следующие шаги
1. Наполнить `backend_service/app.py` минимальным FastAPI-приложением.  
2. Реализовать схему данных и миграции.  
3. Обновить бот: все обращения к БД/RAG → REST вызовы.  
4. Настроить docker-compose (bot + backend + optional redis/mysql).  
5. Автотесты API (pytest + httpx).



